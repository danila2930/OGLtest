#include <GLFW/glfw3.h>
#include <math.h>
#include <cmath>
#include <stdlib.h>

#include <iostream>
#include <vector>
#include <random>



const double PI = 3.14159265358979323846;

const int ROWS = 10000;
const int COLS = 2;

int drawLine(GLFWwindow* window, int StartX, int StartY, int EndX, int EndY) {
    int windowWidth, windowHeight;
    glfwGetFramebufferSize(window, &windowWidth, &windowHeight);

    float x = (StartX / (float)windowWidth) * 2.0f - 1.0f;
    float y = (StartY / (float)windowHeight) * 2.0f - 1.0f;

    float x2 = (EndX / (float)windowWidth) * 2.0f - 1.0f;
    float y2 = (EndY / (float)windowHeight) * 2.0f - 1.0f;
    glBegin(GL_LINES);
    glVertex2f(x, y);
    glVertex2f(x2, y2);
    glEnd();



    return 0;
}

int calculate(GLFWwindow* window , int cords[ROWS][COLS], int StartX, int StartY, float rotate, int curentnum) {

    int windowWidth = 1000, windowHeight = 1000;
    float x = (StartX / (float)windowWidth) * 2.0f - 1.0f;
    float y = (StartY / (float)windowHeight) * 2.0f - 1.0f;
    
    float EndX = 0;
    float EndY = 0;
    float size = 25;
    float radians = rotate * PI / 180.0;

    if (curentnum % 2 == 0) {
        curentnum = curentnum / 2;

        rotate -= 15;
        EndX = StartX + size * cos(radians);
        EndY = StartY + size * sin(radians);
        

    }

    else
    {
        curentnum = curentnum * 3 + 1;

        rotate += 15;

        EndX = StartX + size * cos(radians);
        EndY = StartY + size * sin(radians);
        
    }

    


    if (curentnum != 2) {
        calculate(window, cords, EndX, EndY, rotate, curentnum);
    }

    return EndX, EndY, curentnum, rotate;

    
}





int main(void)
{

    GLFWwindow* window;

    if (!glfwInit())
        return -1;
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
    window = glfwCreateWindow(1000, 1000, "Hello World", NULL, NULL);

    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    glfwMakeContextCurrent(window);

    
    int cords[ROWS][COLS] = { {0} };


    calculate(window, cords, 500, 200, 90, rand() % 100);

    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {

        glClear(GL_COLOR_BUFFER_BIT);



        
        
            
        

        glfwSwapBuffers(window);
        glfwPollEvents();
        /* Swap front and back buffers */


        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}

